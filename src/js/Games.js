import Vector from './Vector';

// Default games data is fetched on build from airmash-refugees/airmash-games repo
import { defaultGamesData } from './GamesData'; 

// Visibility of the drop-down menus
let playRegionMenuVisible = false;
let playTypeMenuVisible = false;
let gamesSelectorVisible = false;

const gameTypes = [
    '',
    'ffa',
    'ctf',
    'br',
    'dev'
];

const gameTypeNames = [
    '',
    'Free For All',
    'Capture The Flag',
    'Battle Royale',
    'Development'
];

const gameTypeDescriptions = [
    '',
    'Everyone versus everyone deathmatch. No teams.',
    'Players split into 2 teams. 2 flags are placed inside each base. The objective is to move the enemy flag from their base to your base.',
    'Players spawn at random locations all across the map. Destroyed players will not respawn. Last player standing wins.',
    'Game environments for development and testing.'
];

let pingHosts = {};
let pingsAwaitingResponse = 0;
let performPingInterval = null;
let closestRegionIndex = null;

let gameHasStarted = false;

let inviteCopiedTimeout = null;

let gamesData = defaultGamesData;
let isGamesDataEmpty = false;

let ctf = {};

let firewallSprites = {};
let minimapFirewallMask = null;
let minimapFirewallVisible = false;
let firewall = {
    radius: 0,
    pos: Vector.zero(),
    speed: 0
};

let unlockedFeature = {};

const loginOrigin = 'https://login.airmash.online';
let loginIdentityProvider = 0;
let loginNonce = null;

Games.setup = function() {
    // Set up all the click event handlers
    $('#playregion').on('click', function(event) {
        Games.updateRegion(true, event)
    });
    $('#playtype').on('click', function(event) {
        Games.updateType(true, event)
    });
    $('#open-menu').on('click', function(event) {
        Games.popGames(),
        event.stopPropagation()
    });
    $('#gameselector').on('click', function(event) {
        event.stopPropagation()
    });
    $('#invite-copy').on('click', Games.copyInviteLink);
    $('#loginbutton').on('click', function(event) {
        UI.openLogin(),
        event.stopPropagation()
    });
    $('#login-microsoft').on('click', function() {
        Games.popupLogin(1)
    });
    $('#login-google').on('click', function() {
        Games.popupLogin(2)
    });
    $('#login-twitter').on('click', function() {
        Games.popupLogin(3)
    });
    $('#login-reddit').on('click', function() {
        Games.popupLogin(4)
    });
    $('#login-twitch').on('click', function() {
        Games.popupLogin(5)
    });
    $('#loginselector').on('click', function(e) {
        e.stopPropagation()
    });
    $('#gotomainpage').on('click', Games.redirRoot);
    $('#lifetime-signin').on('click', Games.redirRoot);
    
    // Loading user authentication data from local storage, if it exists
    if (Tools.loadAuth()) {
        Games.playerAuth();
    }
    else { 
        Games.playerGuest();
    }

    // Poll settings every second to see if any change needs to be sent to backend service
    setInterval(Tools.syncRemoteSettings, 1000);

    Games.updateRegion(false);
    Games.updateType(false);
    pingGameServersForRegions();

    refreshGamesData(function() {
        updatePlayersOnline();
        if (!isGamesDataEmpty) {
            selectGameFromUrlHash();
            Games.updateRegion(false);
            Games.updateType(false);
        }
    }, true);
};

var receiveLoginMessage = function(msg) {
    if (msg.origin !== loginOrigin) {
        console.log('bad origin for login message: ' + msg.origin);
        return;
    }

    if (msg.data.provider !== loginIdentityProvider) {
        console.log('identity provider does not match: ' + msg.data.provider);
        return;
    }
    loginIdentityProvider = 0;
    
    if (msg.data.nonce !== loginNonce) {
        console.log('nonce does not match: ' + msg.data.nonce);
        return;
    }
    loginNonce = null;

    window.loginSuccess({
        tokens: msg.data.tokens,
        identityprovider: msg.data.provider,
        loginname: msg.data.loginname
    });
}

/*
 * The popup window opened on login.airmash.online ends up posting a message
 * back to the main window like so:
 * 
 *   <html>
 *     <head>
 *       <script type="text/javascript">
 *         function closePopup(){ 
 *           window.opener.postMessage({
 *               nonce:       "…",  // randomly generated by client, for CSRF prevention
 *               tokens:      "…",  // tokens used by client to authenticate with settings service and game servers
 *               provider:     …,   // number indicating which identity provider  }- these are for client 
 *               loginname:   "…",  // account name or email                      }  display only
 *              }, "https://…"); // expected to match origin of window.opener e.g. https://airmash.online
 *           window.close();
 *         }
 *       </script>
 *     </head>
 *     <body onload="closePopup()"></body>
 *   </html>
 * 
 * On the original airma.sh, the login window could call window.opener.loginSuccess()
 * directly as they had the same origin. But now we will want to use the same login
 * flow from multiple domains (airmash.online, starma.sh, test.airmash.online, ...),
 * therefore use Window.postMessage() and Window.addEventListener() for cross-origin 
 * communication
 * 
 */
Games.popupLogin = function(identityProvider) {
    window.addEventListener('message', receiveLoginMessage, { once : true });

    loginIdentityProvider = identityProvider;
    loginNonce = Tools.randomID(32);
    let url = `${loginOrigin}/login?provider=${loginIdentityProvider}&nonce=${loginNonce}&origin=${window.origin}`;

    openLoginWindow(url, 'Login', identityProvider == 4 ? 900 : 500, identityProvider == 5 ? 800 : 600);
};

var openLoginWindow = function(url, title, width, height) {
    // Calculate window position for centre
    let x = window.screenLeft ? window.screenLeft : window.screenX;
    let y = window.screenTop ? window.screenTop : window.screenY;
    let left = (window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width) / 2 - width / 2 + x;
    let top = (window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height) / 2 - height / 2 + y;

    // Open login window at this position
    window.open(url, title, `width=${width}, height=${height}, top=${top}, left=${left}`);
};

window.loginSuccess = function(loginsettings) {
    Tools.setAuth(loginsettings);
    Games.playerAuth();
    UI.closeLogin();
};

window.loginFailure = function() {};

Games.playerGuest = function() {
    UI.show('#playbutton', true);
    UI.show('#loginbutton', true);
};

Games.playerAuth = function() {
    Tools.ajaxGet(
        `https://${game.backendHost}/settings`,
        config.auth.tokens.settings,
        function(remoteSettings) {
            if (remoteSettings != null) {
                game.loggedIn = true;

                let identityProvider = ['', 'Microsoft', 'Google', 'Twitter', 'Reddit', 'Twitch'][config.auth.identityprovider || 0];
                let htmlName = UI.escapeHTML((config.auth.loginname || '').substr(0, 30));
                htmlName += `<span class="grey">(${identityProvider})</span>`;

                let htmlLogout = htmlName + '<span class="link" onclick="Games.logout()">Logout</span>';
                let htmlMenuLogout = 'Logged in as ' + htmlName + '<span class="button" onclick="Games.logout()">LOG OUT</span>';
                $('#logout').html(htmlLogout);
                $('#logout-mainmenu').html(htmlMenuLogout);

                $('#loginbutton').remove();
                $('#lifetime-account').remove();

                $('#playbutton').html('PLAY');
                UI.show('#playbutton', true);
                
                Tools.setSettings(remoteSettings);
                Tools.applySettingsToGame();
            } else {
                Games.playerGuest();
            }
        });
};

Games.logout = function() {
    Tools.setAuth({});
    Tools.removeSetting('flag');
    Tools.removeSetting('name');
    window.location = window.location;
};

var refreshGamesData = function(callback, fromMainPage) {
    let url = `https://${game.backendHost}/games`;
    if (fromMainPage) {
        url += '?main=1';
    }

    $.ajax({
        url: url,
        dataType: 'json',
        cache: false,
        success: function(response) {
            // Parse games data in response
            try {
                gamesData = JSON.parse(response.data)
            } catch (e) {
                return;
            }

            // Set flag from country code in response
            if (game.myFlag == 'xx') {
                game.myFlag = response.country;
            }

            // On protocol mismatch, reload the page
            if (fromMainPage && game.protocol != response.protocol) {
                if (window.location.hash !== '#reload') {
                    Tools.ajaxPost(`https://${game.backendHost}/clienterror`, { type: 'protocol' }, function() {
                        UI.showMessage('alert', '<span class="mainerror">Protocol update<br>Your client is being updated to the new version</span>', 30000);
                        setTimeout(function() { window.location = '/?' + Tools.randomID(10) + '#reload' }, 5000);
                    });
                }
                else {
                    Tools.ajaxPost(`https://${game.backendHost}/clienterror`, { type: 'protocolretry' });
                }
            }

            // Success callback
            callback();
        },
        error: function() {}
    })
};

var updatePlayersOnline = function() {
    let playerCount = 0;
    let gameCount = 0;
    for (let region of gamesData) {
        for (let regionGame of region.games) {
            if (regionGame.players) {
                playerCount += regionGame.players;
            }
            if (regionGame.bots) {
                playerCount -= regionGame.bots;
            }
            gameCount++;
        }
    }
    if (gameCount === 0) {
        isGamesDataEmpty = true;
        UI.showMessage('alert', '<span class="mainerror">We are currently performing server maintenance<br>Please try again in a few minutes</span>', 30000);
    }
    else {
        let html = '<div class="item smallerpad">' + playerCount + '</div>player' + (playerCount > 1 ? 's' : '') + ' online';
        $('#gameinfo').html(html);
    }
};

var getRegionByName = function(regionName) {
    if (regionName === 'closest') {
        return { name: 'Closest' };
    }

    for (let region of gamesData) {
        if (region.id === regionName) {
            return region;
        }
    }

    if (game.playRegion = 'closest') {
        return { name: 'Closest' };
    }
};

var getGameByRegionAndRoom = function(regionName, gameName) {
    let region = getRegionByName(regionName);
    if (!region || !region.games) {
        // Return null if the specified region has no games
        return null;
    }

    // Check if game name is a game with this id in this region
    for (let regionGame of region.games) {
        if (regionGame.id === gameName) {
            return regionGame;
        }
    }

    // Check if game name is a game type
    let gameType = gameTypes.indexOf(gameName);
    if (gameType != -1) {
        for (let regionGame of region.games) {
            if (regionGame.type == gameType) {
                return { name: gameTypeNames[gameType] };
            }
        }
    }

    return null;
};

var selectGameFromUrlHash = function() {
    let hash = window.location.hash;
    if (hash !== '#reload' && hash != null && !(hash.length < 4 || hash.length > 20)) {
        // Remove leading '#' from URL hash
        hash = hash.substr(1);

        // Format of URL hash is 'region-room', split on '-'
        let regionRoom = hash.split('-');
        if (regionRoom.length == 2) {
            let [ region, room ] = regionRoom;

            // Look up this region and room in games data, and clear URL hash
            if (getGameByRegionAndRoom(region, room) != null) {
                game.playRegion = region;
                game.playRoom = room;
                game.playInvited = true;
                history.replaceState(null, null, '/');
            }
        }
    }
};

Games.selectRegion = function(clickEvent, region) {
    clickEvent.stopPropagation();
    Sound.UIClick();
    game.playRegion = region;
    Games.updateRegion(false);
    Games.updateType();
};

Games.selectGame = function(clickEvent, room) {
    clickEvent.stopPropagation();
    Sound.UIClick();
    game.playRoom = room;
    Games.updateType(false);
};

Games.closeDropdowns = function() {
    if (playTypeMenuVisible) {
        Games.updateType(false);
    }
    if (playRegionMenuVisible) {
        Games.updateRegion(false);
    }
};

Games.updateRegion = function(menuVisible, clickEvent) {
    let html = '';
    let css;

    if (!isGamesDataEmpty) {
        if (clickEvent) {
            clickEvent.stopPropagation();
            if (!playRegionMenuVisible) {
                Sound.UIClick();
            }
        }

        if (menuVisible) {
            UI.closeLogin();
        }

        if (menuVisible == null) {
            menuVisible = playRegionMenuVisible;
        }

        if (menuVisible) {
            if (playTypeMenuVisible) {
                Games.updateType(false);
            }

            // Header row
            html += '<div class="item">';
            html += '<div class="region header">REGION</div>';
            html += '<div class="players header">PLAYERS</div>';
            html += '<div class="ping header">PING</div>';
            html += '<div class="clear"></div>';
            html += '</div>';

            // Closest region
            let autoregion = '';
            if (closestRegionIndex != null) {
                autoregion = '<span class="autoregion">(' + gamesData[closestRegionIndex].name + ')</span>';
            }
            html += '<div class="item selectable' + (game.playRegion === 'closest' ? ' sel' : '') + '" onclick="Games.selectRegion(event, &quot;closest&quot;)">';
            html += '<div class="region chooser">Closest' + autoregion + '</div>'
            html += '<div class="clear"></div>';
            html += '</div>';

            // Named regions
            for (let region of gamesData) {

                // Region total players 
                let hasPlayers = false;
                let playerCount = 0;
                for (let regionGame of region.games) {
                    if (regionGame.players) {
                        playerCount += regionGame.players;
                        hasPlayers = true;
                    }
                    if (regionGame.bots) {
                        playerCount -= regionGame.bots;
                    }
                }
                if (!hasPlayers) {
                    playerCount = '<span class="playersunknown">?</span>';
                }

                // Region ping 
                let ping = '&nbsp;';
                if (region.ping) {
                    ping = Math.round(region.ping) + '<span class="ms">ms</span>';
                }
                
                html += '<div class="item selectable' + (region.id === game.playRegion ? ' sel' : '') + '" onclick="Games.selectRegion(event, &quot;' + region.id + '&quot;)">';
                html += '<div class="region chooser">' + region.name + '</div>';
                html += '<div class="players number">' + playerCount + '</div>';
                html += '<div class="ping chooser nopadding">' + ping + '</div>';
                html += '<div class="clear"></div>';
                html += '</div>';
            }

            // Bottom padding
            html += '<div class="item"></div>';

            css = {
                width: '240px',
                height: 'auto',
                'z-index': '2'
            };

            $('#playregion').removeClass('hoverable');

        } else {
            // Dropdown menu not visible (closed)
            html += '<div class="arrowdown"></div>';
            html += '<div class="playtop">REGION</div>';
            html += '<div class="playbottom">' + getRegionByName(game.playRegion).name + '</div>';
            css = {
                width: '130px',
                height: '40px',
                'z-index': 'auto'
            };
            $('#playregion').addClass('hoverable');
        }

        $('#playregion').html(html);
        $('#playregion').css(css);
        playRegionMenuVisible = menuVisible;
    }
};

var getSelectedOrClosestRegionId = function() {
    let regionId = game.playRegion;

    // If no region has been selected, get closest if known
    if (regionId === 'closest') {
        if (closestRegionIndex == null) {
            return null;
        }
        regionId = gamesData[closestRegionIndex].id;
    }

    return regionId;
};

var getGameTypeDescriptionHtml = function(gameType) {
    return `<div class="infott">${gameTypeDescriptions[gameType]}<div class="arrow"></div></div>`;
};

Games.updateType = function(menuVisible, clickEvent) {
    let html = '';
    let css = null;

    if (!isGamesDataEmpty) {
        if (clickEvent) {
            clickEvent.stopPropagation();
            if (!playTypeMenuVisible) {
                Sound.UIClick();
            }
        }

        if (menuVisible) {
            UI.closeLogin();
        }

        if (menuVisible == null) {
            menuVisible = playTypeMenuVisible;
        }
        
        if (menuVisible) {
            if (playRegionMenuVisible) { 
                Games.updateRegion(false);
            }

            // Header row
            html += '<div class="item">';
            html += '<div class="gametype header">GAME</div>';
            html += '<div class="players header">PLAYERS</div>';
            html += '<div class="bots header">BOTS</div>';
            html += '<div class="clear"></div>';
            html += '</div>';

            // Do not display if no region selected (including autoselect of closest)
            let selectedRegionId = getSelectedOrClosestRegionId();
            if (selectedRegionId == null) {
                return;
            }

            // Default to first game type (FFA) if none selected
            if (getGameByRegionAndRoom(selectedRegionId, game.playRoom) == null) {
                game.playRoom = gameTypes[1];
            };

            let roomsByType = [[],[],[],[],[],[],[],[],[]];
            
            let regionRooms = getRegionByName(selectedRegionId).games;
            for (let room of regionRooms) {
                roomsByType[room.type].push(room);
            }

            for (let type = 1; type < gameTypes.length; type++) {
                if (roomsByType[type].length > 0) {
                    html += '<div class="item selectable' + (gameTypes[type] === game.playRoom ? ' sel' : '') + '" onclick="Games.selectGame(event, &quot;' + gameTypes[type] + '&quot;)">';
                    html += '<div class="gametype chooser">' + gameTypeNames[type];
                    html += '<span class="infocontainer">&nbsp;<div class="infoicon">' + getGameTypeDescriptionHtml(type) + '</div></span>';
                    html += '</div>';
                    html += '<div class="clear"></div>';
                    html += '</div>';

                    for (let room of roomsByType[type]) {
                        html += '<div class="item selectable' + (room.id === game.playRoom ? ' sel' : '') + '" onclick="Games.selectGame(event, &quot;' + room.id + '&quot;)">';
                        html += '<div class="gametype chooser">' + room.nameShort + '</div>';
                        html += '<div class="players number">' + (room.players != null ? (room.players - (room.bots || 0)) : '<span class="playersunknown">?</span>') + '</div>';
                        html += '<div class="bots number">' + (room.bots ? `+${room.bots}` : '') + '</div>';
                        html += '<div class="clear"></div>';
                        html += '</div>';
                    }
                }
            }

            html += '<div class="item"></div>';

            css = {
                width: '280px',
                height: 'auto',
                'z-index': '2'
            };

            $('#playtype').removeClass('hoverable');
        } else {
            html += '<div class="arrowdown"></div>',
            html += '<div class="playtop">GAME</div>';

            // Do not display if no region selected (including autoselect of closest)
            let selectedRegionId = getSelectedOrClosestRegionId();
            if (selectedRegionId == null) {
                return;
            }

            let selectedGame = getGameByRegionAndRoom(selectedRegionId, game.playRoom);
            if (selectedGame == null) { 
                name = gameTypeNames[1];
                game.playRoom = gameTypes[1];
            } 
            else { 
                name = selectedGame.name;
            }

            html += '<div class="playbottom">' + name + '</div>';

            css = {
                width: '190px',
                height: '40px',
                'z-index': 'auto'
            };

            $('#playtype').addClass('hoverable');
        }

        $('#playtype').html(html);
        $('#playtype').css(css);

        playTypeMenuVisible = menuVisible;
    }
};

Games.popGames = function() {
    if (!gamesSelectorVisible) {
        UI.closeAllPanels('games');
        let html = getGameSelectorHtml();
        UI.hide('#menu');
        $('#gameselector').html(html);
        UI.show('#gameselector');
        gamesSelectorVisible = true;
        updateGameSelector();
        Sound.UIClick();
    }
};

var getGameSelectorHtml = function() {
    let html = '';

    html += '<div class="header">' + game.roomNameShort;
    html += '<span class="region">&nbsp;&nbsp;&bull;&nbsp;&nbsp;' + game.regionName + '</span>';
    html += '</div>';
    html += '<div class="buttons">';
    html += '<div class="button" onclick="Games.redirRoot()">CHANGE REGION</div>';
    html += '</div>';

    let roomsByType = [[],[],[],[],[],[],[],[],[]];

    let regionRooms = getRegionByName(game.playRegion).games;
    for (let room of regionRooms) {
        roomsByType[room.type].push(room);
    }

    for (let type = 1; type < gameTypes.length; type++) {
        if (roomsByType[type].length > 0) {
            html += '<div class="item head">';
            html += '<div class="gametype chooser section">' + gameTypeNames[type];
            html += '<span class="infocontainer">&nbsp;<div class="infoicon">' + getGameTypeDescriptionHtml(type) + '</div></span>'
            html += '</div>';
            html += '<div class="clear"></div>';
            html += '</div>';

            for (let room of roomsByType[type]) {
                let divClass, divAttribute;

                if (room.id === game.playRoom) {
                    divClass = ' sel';
                    divAttribute = '';
                }
                else {
                    divClass = ' selectable';
                    divAttribute = ` onclick="Games.switchGame(&quot;${game.playRegion}-${room.id}&quot;)"`;
                }

                html += '<div class="item' + divClass + '"' + divAttribute + '>';
                html += '<div class="gametype chooser">' + room.nameShort + '</div>';
                html += '<div class="players number">' + (room.players != null ? (room.players - (room.bots || 0)) : '<span class="playersunknown">?</span>') + '</div>';
                html += '<div class="bots number">' + (room.bots ? `+${room.bots}` : '') + '</div>';
                html += '<div class="clear"></div>';
                html += '</div>';
            }
        }
    }

    return html;
};

Games.redirRoot = function() {
    game.reloading = true;
    window.location = '/';
};

var updateGameSelector = function() {
    refreshGamesData(function() {
        let html = getGameSelectorHtml();
        $('#gameselector').html(html);
    });
};

Games.closeGames = function() {
    if (gamesSelectorVisible) {
        UI.hide('#gameselector');
        UI.show('#menu');
        gamesSelectorVisible = false;
        Sound.UIClick();
    }
};

Games.toggleGames = function() {
    if (gamesSelectorVisible) {
        Games.closeGames();
    }
    else {
        Games.popGames();
    }
};

Games.switchGame = function(gameServerId) {
    Games.closeGames();
    if (gameServerId != null) {
        let regionRoom = gameServerId.split('-');
        if (regionRoom.length == 2) {
            [ game.playRegion, game.playRoom ] = regionRoom;
        }
    }
    game.myScore = 0;
    game.server = {};
    game.state = Network.STATE.CONNECTING;
    Network.shutdown();
    Particles.wipe();
    Players.wipe();
    Mobs.wipe();
    UI.reconnection();
    Games.start(game.myOriginalName);
};

var pingGameServersForRegions = function() {
    pingHosts = {};
    pingsAwaitingResponse = 0;

    for (let regionIndex = 0; regionIndex < gamesData.length; regionIndex++) {
        // Pick a host for pinging randomly from games in region
        let games = gamesData[regionIndex].games;
        let host = games[Tools.randInt(0, games.length - 1)].host;
        if(pingHosts[host] == null) {
            pingHosts[host] = {
                ping: 9999,
                num: 0,
                threshold: 0,
                server: regionIndex
            };
        }
    }

    Games.performPing();
    Games.performPing();
    Games.performPing();
    performPingInterval = setInterval(Games.performPing, 300);
};

Games.performPing = function() {
    if (!gameHasStarted && pingsAwaitingResponse <= 3) {
        let pingNum = 9999;
        let pingHost;

        // Pick a host with the smallest number of pings
        for (let host in pingHosts) {
            if (pingHosts[host].num < pingNum) {
                pingNum = pingHosts[host].num;
                pingHost = host;
            }
        }

        // Stop pinging when threshold reached, or ping host if not
        if (pingNum > 6) {
            
            if (performPingInterval) {
                clearInterval(performPingInterval);
            }
        }
        else {
            pingHosts[pingHost].num++;
            let url = `https://${pingHost}/ping`;
            performSinglePing(pingHost, url, function() {
                performSinglePing(pingHost, url);
            });
        }
    }
};

var performSinglePing = function(host, url, callback) {
    if (!gameHasStarted && pingHosts[host] != null) {
        pingsAwaitingResponse++;
        let pingStartTimestamp = performance.now();
        fetch(url, { method: 'GET', mode: 'no-cors', cache: 'no-cache' })
            .then(_ => {
                pingsAwaitingResponse--;

                if (!gameHasStarted && pingHosts[host] != null) {
                    let ping = performance.now() - pingStartTimestamp;

                    // Have we made at least three pings to this host, and is this ping is within 10% of previous ping?
                    pingHosts[host].threshold++;
                    if ((Math.abs(pingHosts[host].ping - ping) < 0.1 * ping) && pingHosts[host].threshold >= 2) {
                        // Is this ping is lower than previous ping?
                        if (ping < pingHosts[host].ping) {
                            // Update region with this ping
                            gamesData[pingHosts[host].server].ping = ping;
                            Games.findClosest();
                            Games.updateRegion();
                        }
                        else {
                            // Stop pinging this host
                            delete pingHosts[host];
                        }
                    }
                    else {
                        // Is this ping is lower than previous ping?
                        if (ping < pingHosts[host].ping) {
                            // Update host and region with this ping
                            pingHosts[host].ping = ping;
                            gamesData[pingHosts[host].server].ping = ping;
                            Games.findClosest();
                            Games.updateRegion();

                            if (callback) {
                                callback();
                            }
                        }
                    }
                }
            })
            .catch(_ => {
                pingsAwaitingResponse--;
            });
    }
};

Games.findClosest = function() {
    let lowestPing = 9999;
    let foundClosestRegion = false;

    for (let index = 0; index < gamesData.length; index++) {
        let region = gamesData[index];
        if (region.ping && region.ping < lowestPing) {
            lowestPing = region.ping;
            closestRegionIndex = index;
            foundClosestRegion = true;
        }
    }

    if (foundClosestRegion && game.playRegion === 'closest') {
        Games.updateType();
    }
};

Games.highlightInput = function(id) {
    $(id).css({
        transition: 'none',
        transform: 'scale(1.1)',
        'background-color': 'rgb(90, 30, 30)'
    });
    $(id).width();
    $(id).css({
        transition: 'all 0.5s ease-in-out',
        transform: 'scale(1)',
        'background-color': 'rgb(30, 30, 30)'
    });
    setTimeout(function() { $(id).focus() }, 200);
};

Games.copyInviteLink = function() {
    if (copyToClipboard(game.inviteLink)) {
        UI.show('#invite-copied');
        if (inviteCopiedTimeout) {
            clearTimeout(inviteCopiedTimeout);
        }
        inviteCopiedTimeout = setTimeout(function() { UI.hide('#invite-copied') }, 2000);
    }
};

var copyToClipboard = function(content) {
    let span = document.createElement('span');
    span.textContent = content;
    span.style.whiteSpace = 'pre';

    let iframe = document.createElement('iframe');
    iframe.sandbox = 'allow-same-origin';
    document.body.appendChild(iframe);
    let contentWindow = iframe.contentWindow;
    contentWindow.document.body.appendChild(span);

    let selection = contentWindow.getSelection();
    if (!selection) {
        contentWindow = window;
        selection = contentWindow.getSelection();
        document.body.appendChild(span);
    }

    let range = contentWindow.document.createRange();
    selection.removeAllRanges();
    range.selectNode(span);
    selection.addRange(range);

    let copyResult = false;
    try {
        copyResult = contentWindow.document.execCommand('copy')
    } catch (e) {}

    selection.removeAllRanges();
    span.remove();
    iframe.remove();

    return copyResult;
};

Games.start = function(playerName, fromMainPage) {
    if (isGamesDataEmpty && !DEVELOPMENT) {
        return;
    }

    if (fromMainPage && game.state == Network.STATE.CONNECTING) {
        return;
    }

    let savedRegionId = game.playRegion;

    if (!(DEVELOPMENT && game.customServerUrl)) {
        // Region
        let regionId = getSelectedOrClosestRegionId();
        if (!regionId) {
            return;
        }
        game.playRegion = regionId;

        // Room
        let roomId = getSelectedRoomId();
        let regionGame = getGameByRegionAndRoom(game.playRegion, roomId);
        game.playHost = regionGame.host;
        game.playPath = regionGame.path;
        game.roomNameShort = regionGame.nameShort;
        game.regionName = getRegionByName(game.playRegion).name;
        game.playRoom = roomId;
    }

    // Stop any pinging of the game server hosts
    if (performPingInterval != null) {
        clearInterval(performPingInterval);
    }
    gameHasStarted = true;

    // Clear the main page if we're on it
    if (game.state == Network.STATE.LOGIN) {
        Tools.wipeReel();
    }
    game.state = Network.STATE.CONNECTING;

    // Any change to player name gets saved to settings upon game start
    let settings = {
        name: playerName
    };

    if (!(DEVELOPMENT && game.customServerUrl)) {
        game.server = { id: `${game.playRegion}-${game.playRoom}` };

        if (!game.playInvited) {
            // Saved region id is used for settings because it might be 'closest' rather than an actual region
            settings.region = savedRegionId;
        }
    } else {
        game.server = { id: `custom-${game.customServerUrl}` };
    }

    // Persist settings to storage
    Tools.setSettings(settings);

    UI.gameStart(playerName, fromMainPage);

    // Usage telemetry. Only send if browser DNT is disabled
    if(navigator.doNotTrack !== '1') {
        Tools.ajaxPost(`https://${game.backendHost}/enter`, {
            id: config.settings.id,
            name: playerName,
            game: game.server.id,
            source: document.referrer != null ? document.referrer : '',
            mode: config.mobile ? 1 : 0,
            version: game.version,
            switch: !fromMainPage
        });
    }
};

function getSelectedRoomId() {
    let room = game.playRoom;

    // If the room is a game type, choose a game of that type at random
    let gameType = gameTypes.indexOf(room);
    if (gameType != -1) {
        let regionGames = getRegionByName(game.playRegion).games;
        let gameIds = [];
        for (let regionGame of regionGames) {
            if (regionGame.type == gameType) {
                gameIds.push(regionGame.id);
            }
        }
        room = gameIds[Tools.rand(0, 1) < .5 ? (gameIds.length - 1) : Tools.randInt(0, gameIds.length - 1)];
    }

    return room;
}

/**
 * Prepare new game upon receipt of LOGIN message
 */
Games.prep = function() {
    // Remove anything that may persist from previous game type
    Games.wipe();

    switch(game.gameType) {
        case GameType.CTF:
            // Display CTF status (team flags and their carriers) in game-specific region
            $('#gamespecific').html(
                '<div class="blueflag"></div>' +
                '<div id="blueflag-name" class="blueflag-player">&nbsp;</div>' + 
                '<div class="redflag"></div>' + 
                '<div id="redflag-name" class="redflag-player">&nbsp;</div>'
                );
            UI.show('#gamespecific');

            // Set up game state for CTF, including sprites
            ctf = {
                flagBlue: {
                    visible: false,
                    playerId: null,
                    direction: 1,
                    diffX: 0,
                    momentum: 0,
                    position: Vector.zero(),
                    basePos: new Vector(-9669,-1471),
                    sprite: Textures.init('ctfFlagBlue', {
                        scale: 0.4,
                        visible: false
                    }),
                    spriteShadow: Textures.init('ctfFlagShadow', {
                        scale: 0.4 * 1.1,
                        visible: false
                    }),
                    minimapSprite: Textures.init('minimapFlagBlue'),
                    minimapBase: Textures.init('minimapBaseBlue')
                },
                flagRed: {
                    visible: false,
                    playerId: null,
                    direction: 1,
                    diffX: 0,
                    momentum: 0,
                    position: Vector.zero(),
                    basePos: new Vector(8602,-944),
                    sprite: Textures.init('ctfFlagRed', {
                        scale: 0.4,
                        visible: false
                    }),
                    spriteShadow: Textures.init('ctfFlagShadow', {
                        scale: 0.4 * 1.1,
                        visible: false
                    }),
                    minimapSprite: Textures.init('minimapFlagRed'),
                    minimapBase: Textures.init('minimapBaseRed')
                }
            };

            // Display team bases on minimap
            Graphics.minimapMob(ctf.flagBlue.minimapBase, ctf.flagBlue.basePos.x, ctf.flagBlue.basePos.y);
            Graphics.minimapMob(ctf.flagRed.minimapBase, ctf.flagRed.basePos.x, ctf.flagRed.basePos.y);
            break;
        
        case GameType.BTR:
            // Clear game-specific region
            $('#gamespecific').html('');
            UI.show('#gamespecific');
            break;
    }    
};

Games.wipe = function() {
    // Clear BTR firewall
    removeFirewall();

    // If exists, clear all CTF graphics
    if (ctf.flagBlue && ctf.flagRed) {
        game.graphics.layers.flags.removeChild(ctf.flagBlue.sprite);
        game.graphics.layers.flags.removeChild(ctf.flagRed.sprite);
        game.graphics.layers.shadows.removeChild(ctf.flagBlue.spriteShadow);
        game.graphics.layers.shadows.removeChild(ctf.flagRed.spriteShadow);
        game.graphics.layers.ui3.removeChild(ctf.flagBlue.minimapSprite);
        game.graphics.layers.ui3.removeChild(ctf.flagRed.minimapSprite);
        game.graphics.layers.ui2.removeChild(ctf.flagBlue.minimapBase);
        game.graphics.layers.ui2.removeChild(ctf.flagRed.minimapBase);
        ctf.flagBlue.sprite.destroy();
        ctf.flagRed.sprite.destroy();
        ctf.flagBlue.spriteShadow.destroy();
        ctf.flagRed.spriteShadow.destroy();
        ctf.flagBlue.minimapSprite.destroy();
        ctf.flagRed.minimapSprite.destroy();
        ctf.flagBlue.minimapBase.destroy();
        ctf.flagRed.minimapBase.destroy();
    }
};

/**
 * GAME_FLAG message handler
 */
Games.networkFlag = function(msg) {
    // Check if this is a blue (1) or red (2) team flag
    let flag, selector, flagCaptures;
    if (msg.flag == 1) {
        flag = ctf.flagBlue;
        selector = '#blueflag-name';
        flagCaptures = msg.blueteam;
    }
    else {
        flag = ctf.flagRed;
        selector = '#redflag-name';
        flagCaptures = msg.redteam;
    }

    // Common values for flag display
    flag.momentum = 0;
    flag.direction = 1;
    flag.sprite.scale.x = 0.4;
    flag.sprite.rotation = 0;
    flag.spriteShadow.scale.x = 0.4 * 1.1;
    flag.spriteShadow.rotation = 0;

    // Team score (successful flag captures)
    let html = `<span class="rounds">${flagCaptures}<span class="divider">/</span>3</span>`;

    if (msg.type == 1) {
        // Flag is not being carried
        flag.playerId = null;
        flag.position.x = msg.posX;
        flag.position.y = msg.posY;
        flag.sprite.position.set(msg.posX, msg.posY);
        let shadow = Graphics.shadowCoords(new Vector(msg.posX,msg.posY));
        flag.spriteShadow.position.set(shadow.x, shadow.y),
        Graphics.minimapMob(flag.minimapSprite, msg.posX, msg.posY);
        $(selector).html(html);
    } else {
        // Flag is being carried
        flag.playerId = msg.id;
        let player = Players.get(msg.id);
        if (player != null) {
            // Position of player name is to the left for blue, right for red
            if (msg.flag == 1) {
                html = UI.escapeHTML(player.name) + html;
            }
            else {
                html += UI.escapeHTML(player.name);
            }
        }
        flag.diffX = player.pos.x;
        $(selector).html(html);
    }

    updateCtfFlag(flag, false);
};

var updateCtfFlag = function(flag, isResize) {
    // If window is being resized, redraw minimap
    if(isResize) {
        Graphics.minimapMob(flag.minimapSprite, flag.position.x, flag.position.y);
        Graphics.minimapMob(flag.minimapBase, flag.basePos.x, flag.basePos.y);
    }

    if(flag.playerId != null) {
        // Flag is being carried
        let carrier = Players.get(flag.playerId);
        if (carrier != null) {
            // Flag visibility must match visibility of flag carrier player (i.e. are they on-screen?)
            if(carrier.render != flag.visible) {
                flag.visible = carrier.render;
                flag.sprite.visible = carrier.render;
                flag.spriteShadow.visible = carrier.render;

                if(carrier.render) {
                    flag.momentum = 0;
                    flag.direction = 1;
                    flag.diffX = carrier.pos.x;
                }
            }

            // Accuracy of flag minimap position depends on whether flag carrier player is visible
            if(carrier.render) {
                Graphics.minimapMob(flag.minimapSprite, carrier.pos.x, carrier.pos.y);
            } else {
                Graphics.minimapMob(flag.minimapSprite, carrier.lowResPos.x, carrier.lowResPos.y);
            }
        }

        // Display flag if flag carrier player is visible
        if(flag.visible) {
            flag.position.x = carrier.pos.x;
            flag.position.y = carrier.pos.y;
            flag.sprite.position.set(carrier.pos.x, carrier.pos.y);

            let shadow = Graphics.shadowCoords(carrier.pos);
            flag.spriteShadow.position.set(shadow.x, shadow.y),

            flag.momentum = Tools.clamp(flag.momentum + (carrier.pos.x - flag.diffX) * game.timeFactor, -40, 40);
            let directionModifier = flag.momentum > 0 ? 0.1 : -0.1;
            flag.direction = Tools.clamp(flag.direction - directionModifier * game.timeFactor, -0.4, 0.4);
            flag.sprite.scale.x = flag.direction;
            flag.spriteShadow.scale.x = 1.1 * flag.direction;

            let rotation = 0.04 * -(carrier.pos.x - flag.diffX) * game.timeFactor;
            flag.sprite.rotation = rotation;
            flag.spriteShadow.rotation = rotation;

            flag.diffX = carrier.pos.x;
        }
    } else {
        // Flag is not being carried, display if on-screen
        let isVisible = Graphics.inScreen(flag.position, 128);
        if(isVisible != flag.visible) {
            flag.visible = isVisible;
            flag.sprite.visible = isVisible;
            flag.spriteShadow.visible = isVisible;
        }
    }
};

/**
 * GAME_SPECTATE message handler
 */
Games.spectate = function(playerId) {
    // If entering spectator mode and we're not playing BTR, display message
    if (game.spectatingID == null && game.gameType !== GameType.BTR) {
        UI.showMessage('alert', '<span class="info">SPECTATOR MODE</span>Click on Respawn to resume playing', 4000);
    }
    game.spectatingID = playerId;

    // Display spectator status text
    let html = '';
    let player = Players.get(playerId);
    html += '<div id="spectator-tag" class="spectating">Spectating ' + (player == null ? '' : UI.escapeHTML(player.name)) + '</div>';
    html += '<div class="buttons">'
    html += '<div onclick="Network.spectateNext()" class="changeplayer left"><div class="arrow"></div></div>';
    html += '<div onclick="Network.spectatePrev()" class="changeplayer right"><div class="arrow"></div></div>';
    html += '</div>';

    UI.showSpectator(html);
};

/**
 * Switch to spectating another player after a delay
 * 
 * This is for when players are killed or leave the game
 */
Games.spectatorSwitch = function(id) {
    setTimeout(function() {
        if (id === game.spectatingID) {
            Network.spectateNext();
        }
    }, 2000);
};

/**
 * GAME_PLAYERSALIVE message handler
 * 
 * Displays number of players still alive - this is for BTR
 */
Games.playersAlive = function(numberAlive) {
    let html = '';
    if (numberAlive > 1) {
        html = `<div class="playersalive">${numberAlive} players alive</div>`;
    }
    $('#gamespecific').html(html);
};

/**
 * SERVER_CUSTOM type 1 (BTR) message handler
 */
Games.showBTRWin = function(info) {
    // Only display if no other custom message is currently displayed
    if (!$('#custom-msg').length) {
        let html = '';
        
        // Trophy image, number of kills, and bounty awarded to player
        html += '<div id="custom-msg" class="btrwin">';
        html += '<div class="trophy"></div>';
        html += '<div class="winner">';
        html += '<div class="player"><span class="flag big flag-' + UI.escapeHTML(info.f) + '"></span>' + UI.escapeHTML(info.p) + '</div>';
        html += '</div>';
        html += '<div class="bounty">';
        html += '<span class="stat">' + UI.escapeHTML(info.k) + ' KILL' + (info.k == 1 ? '' : 'S') + '</span>';
        html += '+' + UI.escapeHTML(info.b) + ' BOUNTY';
        html += '</div>';
        html += '</div>';

        // Display message and play sound
        $('body').append(html);
        UI.showPanel('#custom-msg');
        setTimeout(function() {
            UI.hidePanel('#custom-msg', false, true);
        }, 1000 * info.t);
        Sound.gameComplete();
    }
};

/**
 * SERVER_CUSTOM type 2 (CTF) message handler
 */
Games.showCTFWin = function(info) {
    // Only display if no other custom message is currently displayed
    if (!$('#custom-msg').length) {
        let html = '';
        
        // Trophy, winning team, and bounty awarded to player
        html += '<div id="custom-msg" class="ctfwin">';
        html += '<div class="trophy"></div>';
        html += '<div class="winner">' + (info.w == 1 ? '<div class="player blue">BLUE TEAM</div>' : '<div class="player red">RED TEAM</div>') + '</div>';
        html += '<div class="bounty">+' + UI.escapeHTML(info.b) + ' BOUNTY</div></div>';

        // Display message and play sound
        $('body').append(html);
        UI.showPanel('#custom-msg');
        setTimeout(function() {
            UI.hidePanel('#custom-msg', false, true)
        }, 1000 * info.t);
        Sound.gameComplete();
    }
};

Games.showLevelUp = function(level) {
    // Clear any existing custom message
    if ($('#custom-msg').length) {
        $('#custom-msg').remove();
    }

    // Feature unlocked text
    let featureUnlockHtml = '';
    let divclass = ' lvlsmaller';
    if (unlockedFeature[level + ''] != null) {
        divclass = '';
        featureUnlockHtml = '<div class="unlocked">FEATURE UNLOCKED<br><div class="unlockedtext">' + unlockedFeature[level + ''] + "</div></div>";
    }

    // New level reached text, and level number in badge
    let html = '<div id="custom-msg" class="levelup' + divclass + '">' +
               '<div class="leveltext">NEW LEVEL REACHED</div>' + 
               '<div class="levelbadge"></div>' +
               '<div class="levelnum">' + level + "</div>" + featureUnlockHtml + "</div>";

    // Display message and play sound
    $('body').append(html);
    UI.showPanel('#custom-msg');
    setTimeout(function() { 
        UI.hidePanel('#custom-msg', false, true, true) 
    }, 2000);
    Sound.levelUp();
};

/**
 * Update firewall sprites and minimap mask
 */
Games.popFirewall = function(firewallPosition, firewallRadius) {
    if (firewallRadius <= 0) {
        firewallRadius = 0;
    }

    // Create Graphics object for firewall minimap mask if it doesn't already exist
    if (!minimapFirewallVisible) {
        minimapFirewallVisible = true;
        minimapFirewallMask = new PIXI.Graphics;
        game.graphics.gui.minimap.mask = minimapFirewallMask;
    }

    // Draw firewall mask on minimap
    minimapFirewallMask.clear();
    minimapFirewallMask.beginFill(0xFFFFFF);
    minimapFirewallMask.drawCircle(
        game.screenX - config.minimapPaddingX - config.minimapSize * (16384 - firewallPosition.x) / 32768, 
        game.screenY - config.minimapPaddingY - config.minimapSize / 2 * (8192 - firewallPosition.y) / 16384, 
        2 * firewallRadius / (256 / config.minimapSize * 256));
    minimapFirewallMask.endFill();

    // Calculate extent of firewall sprite grid
    let horizonalSpriteCount = Math.ceil((game.halfScreenX + 64) / game.scale / 64);
    let verticalSpriteCount =  Math.ceil((game.halfScreenY + 64) / game.scale / 64);
    let activeSprites = {};

    // Coordinates of the visible border
    let camera = Graphics.getCamera();
    let upperLeft =  new Vector(camera.x - game.halfScreenX / game.scale - 64, camera.y - game.halfScreenY / game.scale - 64);
    let upperRight = new Vector(camera.x + game.halfScreenX / game.scale + 64, camera.y - game.halfScreenY / game.scale - 64);
    let lowerLeft =  new Vector(camera.x - game.halfScreenX / game.scale - 64, camera.y + game.halfScreenY / game.scale + 64);
    let lowerRight = new Vector(camera.x + game.halfScreenX / game.scale + 64, camera.y + game.halfScreenY / game.scale + 64);

    // Check if any part of the firewall is currently visible
    if (Tools.distance(firewallPosition.x, firewallPosition.y, upperLeft.x, upperLeft.y) > firewallRadius || 
        Tools.distance(firewallPosition.x, firewallPosition.y, upperRight.x, upperRight.y) > firewallRadius ||
        Tools.distance(firewallPosition.x, firewallPosition.y, lowerLeft.x, lowerLeft.y) > firewallRadius || 
        Tools.distance(firewallPosition.x, firewallPosition.y, lowerRight.x, lowerRight.y) > firewallRadius) {
        
        // Iterate over firewall sprite grid
        for (let x = -horizonalSpriteCount; x <= horizonalSpriteCount; x++) {
            for (let y = -verticalSpriteCount; y <= verticalSpriteCount; y++) {
                let posX = 64 * (Math.floor(camera.x / 64) + 0.5) + 64 * x;
                let posY = 64 * (Math.floor(camera.y / 64) + 0.5) + 64 * y;
                let distance = Tools.distance(posX, posY, firewallPosition.x, firewallPosition.y)

                // If position is outside of firewall radius then we display the hot smoke
                if (distance >= firewallRadius) {
                    let name = `${posX}_${posY}`;
                    activeSprites[name] = true;

                    // Create firewall sprite for this position if it doesn't already exist
                    if (firewallSprites[name] == null)
                    {
                        let sprite = Textures.sprite(`hotsmoke_${Tools.randInt(1, 4)}`);

                        sprite.scale.set(Tools.rand(1.5, 2.5));
                        sprite.anchor.set(0.5, 0.5);
                        sprite.position.set(posX, posY);
                        let maxOpacity = 1;
                        if (Tools.rand(0, 1) > 0.5) {
                            sprite.blendMode = PIXI.BLEND_MODES.ADD;
                            maxOpacity = 0.5;
                        }

                        game.graphics.layers.powerups.addChild(sprite);

                        firewallSprites[name] = {
                            sprite: sprite,
                            rotation: Tools.rand(0, 100),
                            rotationSpeed: Tools.rand(-0.0025, 0.0025),
                            opacity: 0,
                            maxOpacity: maxOpacity,
                            opacitySpeed: distance - firewallRadius >= 64 ? 0.02 : 0.0035,
                            color: Tools.rand(0, 1),
                            colorDir: Tools.rand(0, 1) < 0.5 ? -1 : 1
                        }
                    }
                }
            }
        }
    }

    for (let name in firewallSprites) {
        if (activeSprites[name]) {
            // Animate sprite by varying its display properties
            firewallSprites[name].rotation += firewallSprites[name].rotationSpeed * game.timeFactor;
            firewallSprites[name].opacity += firewallSprites[name].opacitySpeed * game.timeFactor;
            if (firewallSprites[name].opacity > firewallSprites[name].maxOpacity) {
                firewallSprites[name].opacity = firewallSprites[name].maxOpacity
            }
            firewallSprites[name].color += 0.005 * firewallSprites[name].colorDir * game.timeFactor;
            if (firewallSprites[name].color < 0) {
                firewallSprites[name].colorDir = 1;
            }
            if (firewallSprites[name].color > 1) {
                firewallSprites[name].colorDir = -1;
            }

            // Apply properties to sprite
            firewallSprites[name].sprite.rotation = firewallSprites[name].rotation;
            firewallSprites[name].sprite.alpha = firewallSprites[name].opacity;
            firewallSprites[name].sprite.tint = Tools.colorLerp(0xFAA806, 0xFA4F06, firewallSprites[name].color);
        }
        else {
            // Remove this firewall sprite
            game.graphics.layers.powerups.removeChild(firewallSprites[name].sprite);
            firewallSprites[name].sprite.destroy();
            delete firewallSprites[name];
        }
    }
};

/**
 * Remove all BTR firewall sprites and minimap mask
 */
var removeFirewall = function() {
    if (minimapFirewallVisible) {
        for (let name in firewallSprites) {
            game.graphics.layers.powerups.removeChild(firewallSprites[name].sprite),
            firewallSprites[name].sprite.destroy();
        }

        firewallSprites = {};

        game.graphics.gui.minimap.mask = null;

        if (minimapFirewallMask) {
            minimapFirewallMask.destroy();
            minimapFirewallMask = null;
        }

        minimapFirewallVisible = false;
    }
};

/**
 * GAME_FIREWALL message handler
 */
Games.handleFirewall = function(msg) {
    if (msg.status == 0) {
        removeFirewall();
    }
    else {
        firewall.radius = msg.radius;
        firewall.pos.x = msg.posX;
        firewall.pos.y = msg.posY;
        firewall.speed = msg.speed;
        Games.popFirewall(firewall.pos, firewall.radius);
    }
};

/**
 * Frame update handler
 */
Games.update = function(isResize) {
    switch (game.gameType) {
        case GameType.CTF:
            if (ctf.flagBlue) {
                updateCtfFlag(ctf.flagBlue, isResize);
                updateCtfFlag(ctf.flagRed, isResize);
            }
            break;
        case GameType.BTR:
            if (minimapFirewallVisible) {
                firewall.radius += firewall.speed / 60 * game.timeFactor;
                Games.popFirewall(firewall.pos, firewall.radius);
            }
            break;
    }
};
